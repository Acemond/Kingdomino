require("util/table")

local zone_guid = "f9209b"
local tile_guid = "9ab771"

local table_guid = "0f8757"
local castle_guid = "768b9c"
local ready_token_guid = "6cfdbd"
local add_player_guid = "8d17b0"
local remove_player_guid = "fa1b7c"

local not_kingdom = {
  table_guid, add_player_guid, remove_player_guid
}
local not_tile_or_domino = {
  castle_guid, ready_token_guid
}

local pending_movement

local kingdom_size = 5
local grid = 0.1
local tile_size = grid * 2
local current_position = {
  x = 0,
  z = 0
}

function onUpdate()
  if pending_movement then
    return
  end

  local zone = getObjectFromGUID(zone_guid)

  local zone_held_objects, kingdom_objects = {}, {}
  local held_objects = getPlayersObjects()
  local shift = { x = 0, z = 0 }
  for _, object in pairs(zone.getObjects()) do
    if not table.contains(not_kingdom, object.guid) then
      if not table.contains(held_objects, object) then
        table.insert(kingdom_objects, object)
      else
        table.insert(zone_held_objects, object)
      end
    end
  end

  for _, domino in pairs(zone_held_objects) do
    shift.x = getShiftKingdom(kingdom_objects, domino, "x")
    shift.z = getShiftKingdom(kingdom_objects, domino, "z")
  end

  current_position = {
    x = current_position.x + shift.x,
    z = current_position.z + shift.z,
  }
  if not table.equal(shift, { x = 0, z = 0 }) then
    launchAnimation(kingdom_objects, current_position)
  end
end

function getShiftKingdom(kingdom_objects, domino, axis)
  local min_kingdom, max_kingdom = getBoundaries(kingdom_objects, axis)
  local domino_size = getDominoSize(domino, axis)
  local domino_local_position = getObjectFromGUID(zone_guid).positionToLocal(domino.getPosition())

  local shift = tile_size * domino_size
  if domino_local_position[axis] > grid * (kingdom_size - domino_size - 1) then
    return getPossibleShift(min_kingdom, max_kingdom, -shift)
  elseif domino_local_position[axis] < -grid * (kingdom_size - domino_size - 1)then
    return getPossibleShift(min_kingdom, max_kingdom, shift)
  end

  return 0
end

function getPossibleShift(min_kingdom, max_kingdom, space_needed)
  local kingdom_limit = grid * (kingdom_size - 1)
  if space_needed < 0 then
    local shift = space_needed + kingdom_limit - max_kingdom
    if kingdom_limit - max_kingdom < math.abs(space_needed)
        and math.abs(-kingdom_limit - min_kingdom) >= math.abs(shift) then
      return shift
    end
  else
    local shift = space_needed - math.abs(-kingdom_limit - min_kingdom)
    if math.abs(-kingdom_limit - min_kingdom) < space_needed
        and kingdom_limit - max_kingdom >= shift then
      return shift
    end
  end
  return 0
end

function getBoundaries(objects, axis)
  local tiles = {}
  for _, object in pairs(objects) do
    if not table.contains(not_tile_or_domino, object.guid) then
      table.insert(tiles, object)
    end
  end

  return getMinPos(tiles, axis), getMaxPos(tiles, axis)
end

function launchAnimation(objects, new_position)
  -- Waiting 1 frame for tile snap to grid
  pending_movement = Wait.frames(function()
    moveKingdom(objects, new_position)
  end, 1)
end

function getMaxPos(objects, axis)
  local zone = getObjectFromGUID(zone_guid)

  local max
  for _, object in pairs(objects) do
    local world_position = object.getPosition()
    if object.guid ~= tile_guid then
      world_position = getDominoMaxBoundaries(object)
    end

    local local_position = zone.positionToLocal(world_position)[axis]
    if max == nil or local_position > max then
      max = local_position
    end
  end
  if max == nil then
    return 0
  else
    return math.floor(max * (1 / grid) + 0.5) / (1 / grid)
  end
end

function getMinPos(objects, axis)
  local zone = getObjectFromGUID(zone_guid)

  local min
  for _, object in pairs(objects) do
    local world_position = object.getPosition()
    if object.guid ~= tile_guid then
      world_position = getDominoMinBoundaries(object)
    end

    local local_position = zone.positionToLocal(world_position)[axis]
    if min == nil or local_position < min then
      min = local_position
    end
  end
  if min == nil then
    return 0
  else
    return math.floor(min * (1 / grid) + 0.5) / (1 / grid)
  end
end

function getDominoMaxBoundaries(domino)
  local rotation = domino.getRotation().y
  local world_position = domino.getPosition()
  if (rotation > -45 and rotation < 45) or (rotation > 135 and rotation < 225) or (rotation > 315) then
    world_position = {
      world_position.x + 1,
      world_position.y,
      world_position.z
    }
  else
    world_position = {
      world_position.x,
      world_position.y,
      world_position.z + 1
    }
  end

  return world_position
end

function getDominoSize(domino, axis)
  local rotation_y = domino.getRotation().y
  if (rotation_y > -45 and rotation_y < 45) or (rotation_y > 135 and rotation_y < 225) or (rotation_y > 315) then
    if axis == "x" then
      return 2
    else
      return 1
    end
  else
    if axis == "x" then
      return 1
    else
      return 2
    end
  end
end

function getDominoMinBoundaries(domino)
  local rotation = domino.getRotation().y
  local world_position = domino.getPosition()
  if (rotation > -45 and rotation < 45) or (rotation > 135 and rotation < 225) or (rotation > 315) then
    world_position = {
      world_position.x - 1,
      world_position.y,
      world_position.z
    }
  else
    world_position = {
      world_position.x,
      world_position.y,
      world_position.z - 1
    }
  end

  return world_position
end

function getPlayersObjects()
  local all_objects = {}
  for _, player in pairs(Player.getPlayers()) do
    if player.getHoldingObjects() ~= nil then
      for _, object in pairs(player.getHoldingObjects()) do
        table.insert(all_objects, object)
      end
    end
  end
  return all_objects
end

function moveKingdom(kingdom_objects, new_position)
  local zone = getObjectFromGUID(zone_guid)
  local tile = getObjectFromGUID(tile_guid)

  local tile_local_pos = zone.positionToLocal(tile.getPosition())

  local target_local_position = {
    x = new_position.x,
    y = tile_local_pos.y,
    z = new_position.z
  }

  for _, object in pairs(kingdom_objects) do
    local object_local_position = zone.positionToLocal(object.getPosition())
    local object_target_position = {
      target_local_position.x + (object_local_position.x - tile_local_pos.x),
      object_local_position.y,
      target_local_position.z + (object_local_position.z - tile_local_pos.z),
    }
    object.setPositionSmooth(zone.positionToWorld(object_target_position), false, true)
  end

  pending_movement = Wait.condition(function()
    pending_movement = nil
  end, function()
    return math.abs(tile.getPosition().x - zone.positionToWorld(target_local_position).x) < 0.01
        and math.abs(tile.getPosition().y - zone.positionToWorld(target_local_position).y) < 0.01
        and math.abs(tile.getPosition().z - zone.positionToWorld(target_local_position).z) < 0.01
  end)
end
