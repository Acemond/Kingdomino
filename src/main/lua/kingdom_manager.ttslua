require("util/table")

local zone_guid = "f9209b"
local tile_guid = "9ab771"

local table_guid = "0f8757"
local castle_guid = "768b9c"
local ready_token_guid = "6cfdbd"
local add_player_guid = "8d17b0"
local remove_player_guid = "fa1b7c"

local not_kingdom = {
  table_guid, add_player_guid, remove_player_guid
}
local not_tile_or_domino = {
  castle_guid, ready_token_guid
}

local pending_movement

local kingdom_size = 5
local grid = 0.1
local step = 2 * grid
local max_pos = (kingdom_size - 1) * grid
local current_position = {
  x = 0,
  z = 0
}
local current_offset = {
  x = 0,
  z = 0
}

function onUpdate()
  if pending_movement then
    return
  end

  local zone = getObjectFromGUID(zone_guid)

  local zone_held_objects, kingdom_objects = {}, {}
  local held_objects = getPlayersObjects()
  for _, object in pairs(zone.getObjects()) do
    if not table.contains(not_kingdom, object.guid) then
      if not table.contains(held_objects, object) then
        table.insert(kingdom_objects, object)
      else
        table.insert(zone_held_objects, object)
      end
    end
  end

  local old_position = {
    x = current_position.x + current_offset.x,
    z = current_position.z + current_offset.z,
  }

  -- TODO: Reset position on X if domino rotated, on Z if not
  updatePosition(zone_held_objects, kingdom_objects, "x")
  updatePosition(zone_held_objects, kingdom_objects, "z")

  local new_position = {
    x = current_position.x + current_offset.x,
    z = current_position.z + current_offset.z,
  }

  if not table.equal(old_position, new_position) then
    launchAnimation(kingdom_objects, new_position)
  end
end

function updatePosition(zone_held_objects, kingdom_objects, axis)
  local min_kingdom, max_kingdom = getBoundaries(kingdom_objects, axis)
  local min_held, max_held = getBoundaries(zone_held_objects, axis)

  if max_kingdom - min_kingdom >= kingdom_size * grid then
    return current_position[axis] + current_offset[axis]
  end

  if min_kingdom == max_kingdom then
    current_position[axis] = 0
  elseif current_offset[axis] == 0 then
    current_position[axis] = current_position[axis] - (min_kingdom + max_kingdom) / 2
  end

  if max_held > max_kingdom + step then
    current_offset[axis] = -step
  elseif min_held < min_kingdom - step then
    current_offset[axis] = step
  else
    if current_offset[axis] ~= 0 then
      current_position[axis] = current_position[axis] + current_offset[axis]
      current_offset[axis] = 0
    end
  end

  return current_position[axis] + current_offset[axis]
end

function getBoundaries(objects, axis)
  local tiles = {}
  for _, object in pairs(objects) do
    if not table.contains(not_tile_or_domino, object.guid) then
      table.insert(tiles, object)
    end
  end

  return getMinPos(tiles, axis), getMaxPos(tiles, axis)
end

function launchAnimation(objects, new_position)
  -- Waiting 1 frame for tile snap to grid
  pending_movement = Wait.frames(function()
    moveKingdom(objects, new_position)
  end, 1)
end

function getMaxPos(objects, axis)
  local zone = getObjectFromGUID(zone_guid)

  local max
  for _, object in pairs(objects) do
    local world_position = object.getPosition()
    if object.guid ~= tile_guid then
      world_position = getDominoMaxBoundaries(object)
    end

    local local_position = zone.positionToLocal(world_position)[axis]
    if max == nil or local_position > max then
      max = local_position
    end
  end
  if max == nil then
    return 0
  else
    return math.floor(max * (1 / grid) + 0.5) / (1 / grid)
  end
end

function getMinPos(objects, axis)
  local zone = getObjectFromGUID(zone_guid)

  local min
  for _, object in pairs(objects) do
    local world_position = object.getPosition()
    if object.guid ~= tile_guid then
      world_position = getDominoMinBoundaries(object)
    end

    local local_position = zone.positionToLocal(world_position)[axis]
    if min == nil or local_position < min then
      min = local_position
    end
  end
  if min == nil then
    return 0
  else
    return math.floor(min * (1 / grid) + 0.5) / (1 / grid)
  end
end

function getDominoMaxBoundaries(domino)
  local rotation = domino.getRotation().y
  local world_position = domino.getPosition()
  if (rotation > -45 and rotation < 45) or (rotation > 135 and rotation < 225) or (rotation > 315) then
    world_position = {
      world_position.x + 1,
      world_position.y,
      world_position.z
    }
  else
    world_position = {
      world_position.x,
      world_position.y,
      world_position.z + 1
    }
  end

  return world_position
end

function getDominoMinBoundaries(domino)
  local rotation = domino.getRotation().y
  local world_position = domino.getPosition()
  if (rotation > -45 and rotation < 45) or (rotation > 135 and rotation < 225) or (rotation > 315) then
    world_position = {
      world_position.x - 1,
      world_position.y,
      world_position.z
    }
  else
    world_position = {
      world_position.x,
      world_position.y,
      world_position.z - 1
    }
  end

  return world_position
end

function getPlayersObjects()
  local all_objects = {}
  for _, player in pairs(Player.getPlayers()) do
    if player.getHoldingObjects() ~= nil then
      for _, object in pairs(player.getHoldingObjects()) do
        table.insert(all_objects, object)
      end
    end
  end
  return all_objects
end

function moveKingdom(kingdom_objects, new_position)
  local zone = getObjectFromGUID(zone_guid)
  local tile = getObjectFromGUID(tile_guid)

  local tile_local_pos = zone.positionToLocal(tile.getPosition())

  local target_local_position = {
    x = new_position.x,
    y = tile_local_pos.y,
    z = new_position.z
  }

  for _, object in pairs(kingdom_objects) do
    local object_local_position = zone.positionToLocal(object.getPosition())
    local object_target_position = {
      target_local_position.x + (object_local_position.x - tile_local_pos.x),
      object_local_position.y,
      target_local_position.z + (object_local_position.z - tile_local_pos.z),
    }
    object.setPositionSmooth(zone.positionToWorld(object_target_position), false, true)
  end

  pending_movement = Wait.condition(function()
    pending_movement = nil
  end, function()
    return math.abs(tile.getPosition().x - zone.positionToWorld(target_local_position).x) < 0.01
        and math.abs(tile.getPosition().y - zone.positionToWorld(target_local_position).y) < 0.01
        and math.abs(tile.getPosition().z - zone.positionToWorld(target_local_position).z) < 0.01
  end)
end
