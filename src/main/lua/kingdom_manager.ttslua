require("util/table")

local zone_guid = "f9209b"
local tile_guid = "9ab771"

local table_guid = "0f8757"
local castle_guid = "768b9c"
local ready_token_guid = "6cfdbd"
local add_player_guid = "8d17b0"
local remove_player_guid = "fa1b7c"

local not_kingdom = {
  table_guid, add_player_guid, remove_player_guid
}
local not_tile_or_domino = {
  castle_guid, ready_token_guid
}

local pending_movement
local pending_function

local current_kingdom_x = 0
local current_offset_x = 0

function onUpdate()
  local zone = getObjectFromGUID(zone_guid)

  local zone_objects, kingdom_objects = {}, {}
  local held_objects = getPlayersObjects()
  for _, object in pairs(zone.getObjects()) do
    if not table.contains(not_kingdom, object.guid) then
      if not table.contains(held_objects, object) then
        table.insert(kingdom_objects, object)
      end
      table.insert(zone_objects, object)
    end
  end

  local min_x_kingdom, max_x_kingdom = getBoundaries(kingdom_objects)
  local min_x_zone, max_x_zone = getBoundaries(zone_objects)

  local step = 0.2
  if max_x_zone > max_x_kingdom then
    current_offset_x = -step
  elseif min_x_zone < min_x_kingdom then
    current_offset_x = step
  else
    if current_offset_x ~= 0 then
      current_kingdom_x = current_offset_x
      current_offset_x = 0
    end
  end

  if min_x_kingdom == max_x_kingdom then
    current_kingdom_x = 0
  else
    current_kingdom_x = current_kingdom_x - (min_x_kingdom + max_x_kingdom) / 2
  end

  moveKingdom(kingdom_objects, current_kingdom_x + current_offset_x, 0)
end

function getBoundaries(objects)
  local tiles = {}
  for _, object in pairs(objects) do
    if not table.contains(not_tile_or_domino, object.guid) then
      table.insert(tiles, object)
    end
  end

  return getMinPos(tiles, "x"), getMaxPos(tiles, "x")
end

function stopAnimation()
  if pending_movement ~= nil then
    Wait.stop(pending_movement)
    pending_movement = nil
  end
end

function restartAnimation(delay)
  stopAnimation()
  pending_movement = Wait.frames(pending_function, delay)
end

function getMaxPos(objects, axis)
  local zone = getObjectFromGUID(zone_guid)

  local max
  for _, object in pairs(objects) do
    local world_position = object.getPosition()
    if object.guid ~= tile_guid then
      world_position = getDominoMaxBoundaries(object)
    end

    local local_position = zone.positionToLocal(world_position)[axis]
    if max == nil or local_position > max then
      max = local_position
    end
  end
  if max == nil then
    return 0
  else
    return math.floor(max * 10 + 0.5) / 10
  end
end

function getMinPos(objects, axis)
  local zone = getObjectFromGUID(zone_guid)

  local min
  for _, object in pairs(objects) do
    local world_position = object.getPosition()
    if object.guid ~= tile_guid then
      world_position = getDominoMinBoundaries(object)
    end

    local local_position = zone.positionToLocal(world_position)[axis]
    if min == nil or local_position < min then
      min = local_position
    end
  end
  if min == nil then
    return 0
  else
    return math.floor(min * 10 + 0.5) / 10
  end
end

function getDominoMaxBoundaries(domino)
  local rotation = domino.getRotation().y
  local world_position = domino.getPosition()
  if (rotation > -45 and rotation < 45) or (rotation > 135 and rotation < 225) or (rotation > 315) then
    world_position = {
      world_position.x + 1,
      world_position.y,
      world_position.z
    }
  else
    world_position = {
      world_position.x,
      world_position.y,
      world_position.z + 1
    }
  end

  return world_position
end

function getDominoMinBoundaries(domino)
  local rotation = domino.getRotation().y
  local world_position = domino.getPosition()
  if (rotation > -45 and rotation < 45) or (rotation > 135 and rotation < 225) or (rotation > 315) then
    world_position = {
      world_position.x - 1,
      world_position.y,
      world_position.z
    }
  else
    world_position = {
      world_position.x,
      world_position.y,
      world_position.z - 1
    }
  end

  return world_position
end

function getPlayersObjects()
  local all_objects = {}
  for _, player in pairs(Player.getPlayers()) do
    if player.getHoldingObjects() ~= nil then
      for _, object in pairs(player.getHoldingObjects()) do
        table.insert(all_objects, object)
      end
    end
  end
  return all_objects
end

function moveKingdom(kingdom_objects, x_pos, z_pos)
  local zone = getObjectFromGUID(zone_guid)
  local tile = getObjectFromGUID(tile_guid)

  local tile_local_pos = zone.positionToLocal(tile.getPosition())

  local target_local_position = {
    x = x_pos,
    y = tile_local_pos.y,
    z = z_pos
  }

  tile.setPositionSmooth(zone.positionToWorld(target_local_position), false, true)

  for _, object in pairs(kingdom_objects) do
    local object_local_position = zone.positionToLocal(object.getPosition())
    local object_target_position = {
      target_local_position.x + (object_local_position.x - tile_local_pos.x),
      object_local_position.y,
      target_local_position.z + (object_local_position.z - tile_local_pos.z),
    }
    object.setPosition(zone.positionToWorld(object_target_position), false, true)
  end
end

function shiftKingdom(kingdom_objects, x_pos, z_pos)
  local zone = getObjectFromGUID(zone_guid)

  for _, object in pairs(kingdom_objects) do
    local local_position = zone.positionToLocal(object.getPosition())
    local target_local_position = {
      x = local_position.x + x_pos,
      y = local_position.y,
      z = local_position.z + z_pos
    }
    object.setPositionSmooth(zone.positionToWorld(target_local_position), false, true)
  end
end
