--local color = "White"

require("util/table")
require("util/domino")
require("constants/guids")

local kingdom_guids = Guids.player_pieces[color]

local kingdom_size = 5

local table_guid = "0f8757"

local pending_movement
local grid = 0.1
local current_position = {
  x = 0,
  z = 0
}
local locked_kingdom = false
local button_state_locked = true

local lock_y_position = 1.05
local hidden_y_position = 0.5

function onLoad(save_state)
  if save_state ~= "" then
    kingdom_size = JSON.decode(save_state).kingdom_size
    current_position = JSON.decode(save_state).current_position
    locked_kingdom = JSON.decode(save_state).locked_kingdom
    button_state_locked = JSON.decode(save_state).button_state_locked
  end
  createLockButtons()
  createUnlockButtons()
end

function onSave()
  return JSON.encode({
    kingdom_size = kingdom_size,
    current_position = current_position,
    locked_kingdom = locked_kingdom,
    button_state_locked = not locked_kingdom, -- forces update of buttons on load
  })
end

local kingdom_update_frequency = 30
local frame = 0

-- FIXME: optimize this shit that is called player_count times per frame!
function onUpdate()
  if Global.get("game") and locked_kingdom ~= button_state_locked then
    updateLockButtons()
  end
  if pending_movement or locked_kingdom or not Global.getVar("kingdom_size") then
    return
  end

  frame = frame + 1
  if frame % kingdom_update_frequency ~= 0 then
    return
  else
    frame = 0
  end

  kingdom_size = Global.getVar("kingdom_size")
  grid = 0.5 / kingdom_size

  local zone = getObjectFromGUID(kingdom_guids.kingdom_zone)
  local held_objects = getPlayersObjects()
  local held_dominos, kingdom_dominos, objects_to_move = {}, {}, {}
  for _, object in pairs(zone.getObjects()) do
    if table.contains(Guids.dominoes.kingdomino, object.guid)
        or table.contains(Guids.dominoes.queendomino, object.guid)
        or table.contains(Guids.dominoes.age_of_giants, object.guid)
        or object.guid == kingdom_guids.castle_tile then
      if table.contains(held_objects, object) then
        table.insert(held_dominos, object)
      else
        table.insert(kingdom_dominos, object)
      end
    end

    if object.guid ~= table_guid and not table.contains(held_objects, object) then
      table.insert(objects_to_move, object)
    end
  end

  local shift = { x = 0, z = 0 }
  for _, domino in pairs(held_dominos) do
    shift.x = getShiftKingdom(kingdom_dominos, domino, "x")
    shift.z = getShiftKingdom(kingdom_dominos, domino, "z")
  end

  current_position = {
    x = current_position.x + shift.x,
    z = current_position.z + shift.z,
  }
  if not table.equal(shift, { x = 0, z = 0 }) then
    launchAnimation(objects_to_move, current_position)
  end
end

function getShiftKingdom(kingdom_dominos, domino, axis)
  local min_kingdom, max_kingdom = getMinPos(kingdom_dominos, axis), getMaxPos(kingdom_dominos, axis)
  local domino_size = getDominoSize(domino, axis)
  local domino_local_position = getObjectFromGUID(kingdom_guids.kingdom_zone).positionToLocal(domino.getPosition())

  local shift = grid * 2 * domino_size
  if domino_local_position[axis] > grid * (kingdom_size - 1) then
    return getPossibleShift(min_kingdom, max_kingdom, -shift)
  elseif domino_local_position[axis] < -grid * (kingdom_size - 1) then
    return getPossibleShift(min_kingdom, max_kingdom, shift)
  end

  return 0
end

function getPossibleShift(min_kingdom, max_kingdom, space_needed)
  local kingdom_limit = grid * (kingdom_size - 1)
  if space_needed < 0 then
    local shift = space_needed + kingdom_limit - max_kingdom
    if kingdom_limit - max_kingdom < math.abs(space_needed)
        and math.abs(-kingdom_limit - min_kingdom) >= math.abs(shift) then
      return shift
    end

    if space_needed + grid * 2 < 0 then
      return getPossibleShift(min_kingdom, max_kingdom, space_needed + grid * 2)
    else
      return 0
    end
  else
    local shift = space_needed - math.abs(-kingdom_limit - min_kingdom)
    if math.abs(-kingdom_limit - min_kingdom) < space_needed
        and kingdom_limit - max_kingdom >= shift then
      return shift
    end

    if space_needed - grid * 2 > 0 then
      return getPossibleShift(min_kingdom, max_kingdom, space_needed - grid * 2)
    else
      return 0
    end
  end
end

function launchAnimation(objects, new_position)
  -- Waiting 1 frame for tile snap to grid
  pending_movement = Wait.frames(function()
    moveKingdom(objects, new_position)
  end, 1)
end

function getMaxPos(objects, axis)
  local zone = getObjectFromGUID(kingdom_guids.kingdom_zone)

  local max
  for _, object in pairs(objects) do
    local local_position = zone.positionToLocal(object.getPosition())
    if object.guid ~= kingdom_guids.castle_tile then
      local orientation = DominoUtils.getOrientation(object.getRotation().y - zone.getRotation().y)
      local_position = getDominoMaxBoundaries(local_position, orientation)
    end

    if max == nil or local_position[axis] > max then
      max = local_position[axis]
    end
  end
  if max == nil then
    return 0
  else
    return math.floor(max * (1 / grid) + 0.5) / (1 / grid)
  end
end

function getMinPos(objects, axis)
  local zone = getObjectFromGUID(kingdom_guids.kingdom_zone)

  local min
  for _, object in pairs(objects) do
    local local_position = zone.positionToLocal(object.getPosition())
    if object.guid ~= kingdom_guids.castle_tile then
      local orientation = DominoUtils.getOrientation(object.getRotation().y - zone.getRotation().y)
      local_position = getDominoMinBoundaries(local_position, orientation)
    end

    if min == nil or local_position[axis] < min then
      min = local_position[axis]
    end
  end
  if min == nil then
    return 0
  else
    return math.floor(min * (1 / grid) + 0.5) / (1 / grid)
  end
end

function getDominoMaxBoundaries(zone_position, orientation)
  local offset = { x = 0, y = 0, z = 0 }
  if orientation == DominoUtils.orientations.x or orientation == DominoUtils.orientations.x_reverse then
    offset.x = grid
  else
    offset.z = grid
  end

  return {
    x = zone_position.x + offset.x,
    y = zone_position.y + offset.y,
    z = zone_position.z + offset.z,
  }
end

function getDominoSize(domino, axis)
  local rotation_y = domino.getRotation().y
  if (rotation_y > -45 and rotation_y < 45) or (rotation_y > 135 and rotation_y < 225) or (rotation_y > 315) then
    if axis == "x" then
      return 2
    else
      return 1
    end
  else
    if axis == "x" then
      return 1
    else
      return 2
    end
  end
end

function getDominoMinBoundaries(zone_position, orientation)
  local offset = { x = 0, y = 0, z = 0 }
  if orientation == DominoUtils.orientations.x or orientation == DominoUtils.orientations.x_reverse then
    offset.x = -grid
  else
    offset.z = -grid
  end

  return {
    x = zone_position.x + offset.x,
    y = zone_position.y + offset.y,
    z = zone_position.z + offset.z,
  }
end

function getPlayersObjects()
  local all_objects = {}
  for _, player in pairs(Player.getPlayers()) do
    if player.getHoldingObjects() ~= nil then
      for _, object in pairs(player.getHoldingObjects()) do
        table.insert(all_objects, object)
      end
    end
  end
  return all_objects
end

function moveKingdom(kingdom_objects, new_position)
  local zone = getObjectFromGUID(kingdom_guids.kingdom_zone)
  local tile = getObjectFromGUID(kingdom_guids.castle_tile)

  local tile_local_pos = zone.positionToLocal(tile.getPosition())

  local target_local_position = {
    x = new_position.x,
    y = tile_local_pos.y,
    z = new_position.z
  }

  for _, object in pairs(kingdom_objects) do
    local object_local_position = zone.positionToLocal(object.getPosition())
    local object_target_position = {
      target_local_position.x + (object_local_position.x - tile_local_pos.x),
      object_local_position.y,
      target_local_position.z + (object_local_position.z - tile_local_pos.z),
    }
    object.setPositionSmooth(zone.positionToWorld(object_target_position), false, true)
  end

  pending_movement = Wait.condition(function()
    pending_movement = nil
  end, function()
    return math.abs(tile.getPosition().x - zone.positionToWorld(target_local_position).x) < 0.01
        and math.abs(tile.getPosition().y - zone.positionToWorld(target_local_position).y) < 0.01
        and math.abs(tile.getPosition().z - zone.positionToWorld(target_local_position).z) < 0.01
  end)
end

function lockKingdom()
  locked_kingdom = true
end

function unlockKingdom()
  locked_kingdom = false
end

function createLockButtons()
  getObjectFromGUID(Guids.player_pieces[color].lock_kingdom).createButton({
    click_function = "lockKingdom",
    function_owner = self,
    label = "",
    tooltip = "Click to prevent the kingdom from moving away from the edges.",
    position = { 0, 0.05, 0 },
    scale = { 0, 0, 0 },
    color = { 0, 0, 0, 0 },
    width = 800,
    height = 600,
  })
end

function createUnlockButtons()
  getObjectFromGUID(Guids.player_pieces[color].unlock_kingdom).createButton({
    click_function = "unlockKingdom",
    function_owner = self,
    label = "",
    tooltip = "Click for kingdom to move away from the edges.",
    position = { 0, 0.05, 0 },
    scale = { 0, 0, 0 },
    color = { 0, 0, 0, 0 },
    width = 800,
    height = 600,
  })
end

function updateLockButtons()
  local unlock_button = getObjectFromGUID(Guids.player_pieces[color].unlock_kingdom)
  local lock_button = getObjectFromGUID(Guids.player_pieces[color].lock_kingdom)

  if locked_kingdom then
    button_state_locked = true
    hideButton(lock_button)
    Wait.condition(function()
      showButton(unlock_button)
    end, function()
      return lock_button.getPosition().y < 0.9
    end)
  else
    button_state_locked = false
    hideButton(unlock_button)
    Wait.condition(function()
      showButton(lock_button)
    end, function()
      return unlock_button.getPosition().y < 0.9
    end)
  end
end

function showButton(button)
  local kingdom = getObjectFromGUID(Guids.player_pieces[color].kingdom_zone)
  local lock_position = kingdom.positionToWorld({ -(grid * 2) * kingdom_size / 2, 0, -(grid * 2) * (kingdom_size / 2 + 1) })
  button.editButton({ index = 0, scale = { 1, 1, 1 } })
  button.setPosition({ lock_position.x, 0.86, lock_position.z, })
  button.setPositionSmooth({ lock_position.x, lock_y_position, lock_position.z, }, false, true)
end

function hideButton(button)
  local kingdom = getObjectFromGUID(Guids.player_pieces[color].kingdom_zone)
  local lock_position = kingdom.positionToWorld({ -(grid * 2) * kingdom_size / 2, 0, -(grid * 2) * (kingdom_size / 2 + 1) })
  button.editButton({ index = 0, scale = { 0, 0, 0 } })
  button.setPositionSmooth({ lock_position.x, hidden_y_position, lock_position.z, }, false, true)
end
